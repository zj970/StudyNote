# 7. 图  

## 7.1 图的定义 

&emsp;&emsp;在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中的多个元素相关，但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。可现实中，人与人之间关系就非常复杂，比如我认识的朋友，可能他们之间也互相认识，这就不是简单的一对一、一对多，研究人际关系很自然会考虑多对多的情况。那就是图。图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意，图中任意两个数据元素之间都可能相关（如图7.1）。  

<div align="center"><img src="data_structure_image/7/7.1.png"></div>

> 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

&emsp;&emsp;对于图的定义，我们需要明确几个注意的地方

- 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。  
- 线性表中可以没有数据元素，称为空表。书中可以没有结点，叫做空树。那么对于图呢？在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<b>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，</b>边集可以是空的。  

### 7.1.1 各种图定义  

&emsp;&emsp;<b>无向边：若顶点V~i~到V~j~之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(V~i~,V~j~)来表示。</b>如果图中任意两个顶点之间的边都是无向边，则称该图为无向边(Undirected graphs)。图7.2左图就是一个无向图，由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D)，也可以写成(D,A)</b>。  
&emsp;&emsp;对于图7.2左图的无项图G~1~来说，G~1~ = (V~1~,{E~1~})，其中顶点集合V~1~={A,B,C,D};边集合E~1~={(A,B),(B,C),(C,D),(D,A),(A,C)}  

<div align="center"><img src="data_structure_image/7/7.2.png"></div>

&emsp;&emsp;<b>有向边：若从顶点V~i~到V~j~的边有方向，则称这条边为有向边，也称为弧(Arc)</b>。用有序偶<V~i~,V~j~>来表示，V~i~称为弧尾(Tail)，V~j~称为弧头(Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图(Directed graphs)。图7.2右图就是一个有向图。<b>连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A,D>表示弧，注意不能写成<D,A>。</b>  

&emsp;&emsp;对于图7.2右图中的有向图G~2~来说，G~2~=(V~2~,{E~2~})，其中顶点集合V~2~={A,B,C,D}；弧集合E~2~={<A,D>,<B,A>,<C,A>,<B,C>}。<b>无向边用小括号“（）”表示，而有向边则是用尖括号“<>”表示</b>。  
&emsp;&emsp;<b>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</b>  
&emsp;&emsp;<b>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</b>含有n个顶点的无向完全图有n*(n-1)/2条边。比如图7.3就是无向完全图，因为每个顶点都要与除它以外的顶点连线，顶点A与BCD三个顶点连线，共有4个顶点，从4个选出两个进行匹配就是C${ n \choose 2}$，如图7.3所示：  

<div align="center"><img src="data_structure_image/7/7.3.png"></div>

&emsp;&emsp;<b>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</b>含有n个顶点的有向完全图有n*(n-1)条边，如图7.4所示：  

<div align="center"><img src="data_structure_image/7/7.4.png"></div>  

&emsp;&emsp;从这里也可以得到结论，对于具有n个顶点和e条边数的图，无向图0<e<=(n-1)/2，有向图0<e<=n(n-1)  
&emsp;&emsp;<b>有很少条边或弧的图称为稀疏图，反之称为稠密图。</b>有些图的边或弧具有与它相关的数字，这种<b>与图的边或弧相关的数叫做权(Weight)。</b>这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种<b>带权的图通常为网(Network)</b>。图7.5所示就是一张带权的图，即标识中国四大城市的直线距离的网，此图中的权就是两地的距离。  

<div align="center"><img src="data_structure_image/7/7.5.png"></div>  

&emsp;&emsp;<b>假设有两个图G=(V,{E})和G'=(V,{E}),如果V'$\subseteq$V且E'$\subseteq$E，则称G'为G的子图(Subgraph)。</b>如图7.6所示:  

<div align="center"><img src="data_structure_image/7/7.6.png"></div>

### 7.1.2 图的顶点与边间关系  
&emsp;&emsp;<b>对于无向图G=(V,{E}),如果边(v,v')$\in$E，则称顶点v和v'互为邻接点(Adjacent)，即v和v'相邻接。边(v,v')依附(incident)于顶点v和v'，或者说(v,v')与顶点v和v'相关联。顶点v的度(Degree)是和v相关联的边的数目，记为TD(v)</b>。例如图7.6左侧上方的无向图，顶点A与B互为邻接点，边(A,B)依附于顶点A与B上，顶点A的度为3.而此图的边数是5，各个顶点度的和=3+2+3+2=10，推敲后发现，边数其实就是各顶点度数和的一半，多出的一半是因为重复两次记数。简记之，<font color=red>e=1/2$\sum_{i=1}^n$TD(v~i~)</font>。  
&emsp;&emsp;<b>对于有向图G=(V,{E}),如果弧<v,v'>$\in$E，则称顶点v邻接到顶点v'，顶点v'邻接自顶点v。弧<v,v'>和顶点v,v'相关联。以顶点v为开头的弧的数目称为v的入度(InDegree)，记作ID(v)；以v为尾的弧的数目称为v的出度(OutDegree)，记为OD(v)；顶点v的度为TD(v) = ID(v) + OD(v)</b>。例如图7.6左侧下方的有向图，顶点A的入度是2(从B到A的弧，从C到A的弧)，出度是1(从A到D的弧)，所以顶点A的度为2+1=3。此有向图的弧有4条，而各顶点的出度和=1+2+1+0=4，各顶点的入度和=2+0+1+1=4.所以得到<font color=red>e= $\sum_{i=1}^n$ID(v~i~) = $\sum_{i=1}^n$OD(v~i~)。</font>  
&emsp;&emsp;无向图G=(V,{E})中从顶点v到顶点v'的路径(Path)是一个顶点序列(v=v~i,0~,v~i,1~,...,v~i,m~=v')，其中(v~i,j-1~,v~i,j~)$\in$E，1<=j<=m。例如图7.7所示就列举另外顶点B到顶点D四种不同的路径:  

<div align="center"><img src="data_structure_image/7/7.7.png"></div>  

&emsp;&emsp;如果G是有向图，则路径也是有向的，顶点序列应满足<V~i,j-1~,V~i,j~>$\in$E，1<=j<m。例如图7.8，顶点B到D有两种路径。  

<div align="center"><img src="data_structure_image/7/7.8.png"></div>  

&emsp;&emsp;如果G是有向图，则路径也是有向的，顶点序列应满足<V~i,j-1~,V~i,j~>$\in$E,1<=j<m，顶点B到D有两种路径。而顶点A到B，就不存在路径。如图7.9所示  

<div align="center"><img src="data_structure_image/7/7.9.png"></div>  

&emsp;&emsp;树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。  
&emsp;&emsp;<b>路径的长度是路径上的边或弧的数目。</b>图7.8中左侧两条路的长度为2，右侧两条路径长度为3。图7.9中左侧路径长为2，右侧路径长度为3。  
&emsp;&emsp;<b>第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</b>图7.10中两个图的粗线都构成环，左侧的环因第一个顶点和最后一个顶点都是B，且C、D、A没有重复出现，因此是一个简单环。而右侧的环，由于顶点C的重复，它就不是简单环了。  

<div align="center"><img src="data_structure_image/7/7.10.png"></div>

### 7.1.3 连通图相关术语  

&emsp;&emsp;<b>在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点v~i~，v~j~$\in$E,v~i~和v~j~都是连通的，则称G是连通图(Connected Graph)。</b>图7.11图的图1，它的顶点A到顶点B、C、D、都是连通的，但显然A与顶点E或F就无路径，因此不能算是连通图。而图7.11中的图2，定点A、B、C、D相互都是连通的，所以它本身是连通图。  

<div align="center"><img src="data_structure_image/7/7.11.png"></div>

&emsp;&emsp;<b>无向图中的极大连通子图称为连通分量。</b>注意联通分量的概念，它强调：  
- 要是子图；
- 子图要是连通的；
- 连通子图含有极大顶点数；
- 具有极大顶点数的联通子图包含依附于这些顶点的所有边。  

&emsp;&emsp;<b>在有向图G中，如果对于每一对v~i~，v~j~$\in$V、v~i~不等于v~j~，从v~i~到v~j~和从v~j~到v~i~都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。</b>例如图7.12，图1并不是强连通图，因为顶点A到顶点D存在路径，而D到A就只存在。图2就是强连通图，而且显然图2是图1的极大强连通子图，既是它的强连通分量。  

<div align="center"><img src="data_structure_image/7/7.12.png"></div>

&emsp;&emsp;现在查看连通图的生成树定义。  
&emsp;&emsp;所谓的一个<b>连通图的生成树是一个极小的连通子图。它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</b>。比如图7.13的图1是一普通图，但显然它不是生成x树，当去掉两条构成环的边后，比如图2和图3，就满足n个顶点n-1条边且联通的定义了。它们都是一棵生成树。从这里也知道，如果一个图有n个顶点n-1条边和小于n-1条边，则是非连通图，如果它多于n-1条边，必定构成一个环，因为这条边使得它依附的那个顶点之间有了第二条路径。比如图2和图3,随便加哪两个顶点的边都将构成环。不过有n-1条边并不一定是生成树，比如图4。 

<div align="center"><img src="data_structure_image/7/7.13.png"></div>

&emsp;&emsp;<b>如果一个有向图恰好有一个顶点的入度为0,其余顶点的入度均为1,则是一棵有向树。</b>对有向树的理解也比较容易，所谓入度为0其实 就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个。一个<b>有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</b>如7.14图的图1是一棵有向图。去掉一些弧后，它可以分解为两棵有向树，如图2、3,这两棵就是图1有向图的生成森林。  

<div align="center"><img src="data_structure_image/7/7.14.png"></div>

### 7.1.4 图的定义与术语总结

&emsp;&emsp;<font color=red>图</font>按照有无方向分为<font color=blue>无向图和有向图</font>。无向图由<font color=red>顶点和边构成</font>，有向图由<font color=red>顶点和弧</font>构成。弧有<font color=blue>弧尾和弧头之分</font>。  
&emsp;&emsp;图按照边或弧的多少分<font color=blue>稀疏图和稠密图</font>。如果任意两个顶点之间都存在边叫<font color=blue>完全图</font>，有向的叫<font color=blue>有向完全图</font>。若无重复的边或顶点到自身的边则叫<font color=blue>简单图</font>。  
&emsp;&emsp;图中顶点之间有<font color=blue>邻接点、依附</font>的概念。无向图顶点的边数叫做<font color=blue>度</font>，有向图顶点分为<font color=blue>入度和出度</font>。  
&emsp;&emsp;图上的边或弧上<font color=blue>带权则称为网</font>。  
&emsp;&emsp;图中顶点间存在<font color=blue>路径</font>，两顶点存在路径则说明是<b>连通</b>的，如果路径最终回到起始点则称为<font color=blue>环</font>，当环中不重复叫<font color=blue>简单路径</font>。若任意两顶点都是<b>连通</b>的，则图就是<font color=blue>连通图</font>，有向则称为<font color=blue>强连通图</font>。图中有子图，若子图极大连通则就是<font color=blue>连通分量</font>，有向的则称<font color=blue>强连通分量</font>。  
&emsp;&emsp;无向图中连通且n个顶点n-1条边叫做<font color=blue>生成树</font>，有向图中一顶点入度为0其余顶点入度为1的叫<font color=blue>有向树</font>。一个有向图由若干棵有向树构成生成<font color=blue>森林</font>。


## 7.2 图的抽象数据类型  

&emsp;&emsp;图作为一种数据结构，它的抽象类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的数据操作。

```
ADT 图(Graph)

Operation
    CreateGraph(*G,V,VR):按照顶点集V和边弧集VR的定义构造图G
    DestroyGraph(*G):图G存在则销毁  
    LocateVex(G,u):若图G中存在顶点u，则返回图中的位置
    GetVex(G,v):返回图G中顶点v的值
    PutVex(G,v,value):将图G中顶点v赋值value
    FirstAdjVex(G,*v)：返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空
    NextAdjVex(G,v*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”
    InsertVex(*G,v):在图G中增添新顶点v
    DeleteArc(*G,v):删除图G中顶点v及其相关的弧
    InsertArc(*G,v,w):在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>
    DeleteArc(*G,v,w):在图G中删除弧<v,w>,若G是无向图，则还删除对称弧<w,v>
    DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用
    HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用
endADT
```

## 7.3 图的存储结构  

&emsp;&emsp;图的存储结构相较线性表与树来说就更加复杂了。首先，我们口头上说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系。比如图7.15中的四张图，仔细观察发现，它们其实是同一个图，只不过顶点的位置不同，就造成了表象上不太一样的感觉。  

<div align="center"><img src="data_structure_image/7/7.15.png"></div>

&emsp;&emsp;也正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是有问题的。如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的的顶点结构，又带来操作的不便。因此，对于图来说，如何对它实现物理存储是个难题，不过我们的前辈们已经解决了，现在我们来看看前辈们提供的五种不同的存储结构。  

### 7.3.1 邻接矩阵  

&emsp;&emsp;考虑到图是由顶点和边或弧两部分组成。合成一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。于是我们的邻接矩阵的方案就诞生了。  

&emsp;&emsp;<b>图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</b>  
&emsp;&emsp;设图G有n个顶点，则邻接矩阵是一个nxn的方阵，定义为:arc[i][j] = 1,若(v~i~,v~j~)$\in$E或<v~i~,v~j~>$\in$E。arc[i][j] = 0，则相反。我们来看一个实例，图7.16的左图。  

<div align="center"><img src="data_structure_image/7/7.16.png"></div>

&emsp;&emsp;我们可以设置两个数组，顶点数组为vertex[4]={v~0~,v~1~,v~2~,v~3~}，边数组arr[4][4]为图7.16右图这样的一个矩阵。简单解释一下，对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点到自身的边，比如v~0~到v~0~。arc[0][1]=1是因为v~0~到v~1~的边存在，而arc[1][3]=0是因为v~1~到v~3~的边不存在。并且由于是无向图，v~1～到v~3~的边不存在，意味着v~3~到v~1~的边也不存在。所以无向图的边数组是一个对称矩阵。  
&emsp;&emsp;嗯？对称矩阵是什么？忘记了不要紧，复习一下。所谓对称矩阵就是n阶矩阵的元满足a~ij~=a~ji~，（0<=i,j<=n）。即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。  
&emsp;&emsp;有了这个矩阵，我们就可以很容易地知道图中的信息。  
1. 我们要判定任意两顶点是否有边无边就非常容易了。  
2. 我们要知道某个顶点的度，其实就是这个顶点v~i在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v~i~的度就是1+0+1+0=2。
3. 求顶点v~i~的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1即是1邻接点。  

&emsp;&emsp;我们再来看一个有向图样例，如图7.17所示左图：  

<div align="center"><img src="data_structure_image/7/7.17.png"></div>

&emsp;&emsp;顶点数组为vertex[4]={v~0~,v~1~,v~2~,v~3~}，弧数组arc[4][4]为图7.17右图这样的一个矩阵。主对角线上数值依然为0.但因为是有向图，所以此矩阵并不对称，比如由v~1~到v~0~有弧，得到arc[1][0]=1，而v~0~到v~1~没有弧，因此arc[0][1]=0。  
&emsp;&emsp;有向图讲究入度与出度，顶点v~1~的入度为1,正好是第v~1~列各数之和。顶点v~1~的出度为2,即第v~1~行各数的和。  
&emsp;&emsp;与无向图同样的方法，判断顶点v~i~到v~j~是否存在弧，只需要查找矩阵中arc[i][j]是否为1即可。  
 &emsp;&emsp;在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。  
 &emsp;&emsp;设图G是网图，有n个顶点，则邻接矩阵是一个nxn的方阵，定义为: arc[i][j] = W~ij~,若(v~i~,v~j~)$\in$E或<v~i~,v~j~>$\in$E； 若i = j,arc[i][j] = 0;反之 arc[i][j] = $\infin$。  
 &emsp;&emsp;这里W~ij~表示(v~i~,v~j~)或者<v~i~,v~j~>上的权值。$\infin$表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于权值w~ij~大多数情况写是正值，但个别时候可能就是0,甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。如图7.18左图就是一个有向网图，右图就是它的邻接矩阵。  

<div align="center"><img src="data_structure_image/7/7.18.png"></div>  

&emsp;&emsp;那么邻接矩阵是如何实现图的创建的呢？我们先来看看图的邻接矩阵存储的结构，代码如下。  
```
typedef char VertexType;            /*顶点类型应由用户定义*/
typedef int EdgeType;               /*边上的权值类型应由用户定义*/
#define MAXVEX 100;                 /*最大顶点数，应由用户定义*/
#define INFINITY 65535              /*用65535代表无穷大*/

typedef struct
{
    VertextType vexs[MAXVEX];       /*顶点表*/
    EdgeType arc[MAXVEX][MAXVEX];   /*邻接矩阵，可看作边表*/
    int numVertexes, numEdges;      /*图中当前的顶点数和边数*/
}MGraph;
```
&emsp;&emsp;有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。  
```
/*建立无向网图的邻接矩阵表示*/
void CreateMGraph(MGraph *G)
{
    int i,j,k,w;
    printf("输入顶点数和边数:\n");
    scanf("%d,%d",&G->numVertexes,);    /*输入顶点数和边数*/
    for(i = 0, i < G->numVertexes; i++) /*读入顶点信息，建立顶点表*/
    {
        scanf(&G->vexs[i]);
    }
    for(i  = 0; i< G->numVertexes; j++)
    {
        for(j = 0; j< G->numVertexes; j++)
        {
            G->arc[i][j] = INFINITY;    /*邻接矩阵初始化*/
        }
    }

    for(k = 0; k < G->numEdges; k++)    /*读入numEdges条边，建立邻接矩阵*/
    {
        printf("输入边(Vi,Vj)上的下标i,下标j和权w:\n");
        scanf("%d,%d,%d",&i,&j,&w);     /*输入边(vi,vj)上的权w*/
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];    /*因为是无向图，矩阵对称*/
    }
}
```

&emsp;&emsp;从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2^)的时间。  

### 7.3.2 邻接表  

&emsp;&emsp;邻接矩阵是不错的一种图存储结构，但是我们发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。比如说，如果我们要处理图7.19这样的稀疏有向图，邻接矩阵除了arc[1][0]有权值外，没有其他弧，其实这些存储空间都浪费了。  

<div align="center"><img src="data_structure_image/7/7.19.png"></div>  

&emsp;&emsp;因此我们考虑另外一种存储结构方式。回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。  
&emsp;&emsp;再回忆我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题，这种思路同样适用于图的存储。我们把这种<b>数组与链表相结合的存储方法称为邻接表(Adjacency List)</b>。  
&emsp;&emsp;邻接表的处理办法是这样。  
1. 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。  
2. 图中每个顶点v~i~的所有邻接点构成一个线性表，由于邻接点的个树不定，所以用单链表存储，无向图称为顶点v~i~的边表，有向图则称为顶点v~i~作为弧尾的出边表。  

&emsp;&emsp;例如图7.20所示的就是一个无向图的邻接表结构。  

<div align="center"><img src="data_structure_image/7/7.20.png"></div>  

&emsp;&emsp;从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstefge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v~1~顶点与v~0~、v~2~互为邻接点，则在v~1~的边表中，adjvex分别为v~0~的0和v~2~的2。  
&emsp;&emsp;这样的结构，对于我们要获得图的相关信息也是很方便的。比如我们要想知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点v~i~到v~j~是否存在边，只需要测试顶点v~i~的边表中adjvex是否存在结点v~j~的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点。  
&emsp;&emsp;若是有向图，邻接表结构是类似的，比如图7.21中第一幅图的邻接表就是第二幅图。但需要注意的是有向图由于由方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以<b>建立一个有向图的逆邻接表，即对每个顶点v~i~都建立一个链接为v~i~为弧头的表</b>。如图7.21的第三幅图所示。  

<div align="center"><img src="data_structure_image/7/7.21.png"></div>  

&emsp;&emsp;此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现。  
&emsp;&emsp;对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可，如图7.22所示。  

<div align="center"><img src="data_structure_image/7/7.22.png"></div>  

&emsp;&emsp;有了这些结构的图，下面关于结点定义的代码就很好理解了。  

```
typedef char VertexType;            /*顶点类型应由用户定义*/
typedef int EdgeType;               /*边上的权值类型应由用户定义*/

typedef struct EdgeNode             /*边表结点*/
{
    int adjvex;                     /*邻接点域，存储该顶点对应的下标*/
    EdgeType weight;                /*用于存储权值，对于非网图可以不需要*/
    struct EdgeNode *next;          /*链域，指向下一个邻接点*/
}EdgeNode;

typedef struct VertexNode           /*顶点表结点*/
{
    VertexType data;                /*顶点域，存储顶点信息*/
    EdgeNode *firstedge;            /*边表头指针*/
}VertexNode,AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numVertexes,numEdges;       /*图中当前顶点数和边数*/
}GraphAdjList;
```

&emsp;&emsp;对于邻接表的创建，也就是顺理成章之事。无向图的邻接表创建代码如下。  

```
/*建立图的邻接表结构*/
void CreateALGraph(GraphAdjList *G)
{
    int i,j,k;
    EdgeNode *e;
    printf("请输入顶点数和边数:\n");
    scanf("%d,%d",&G->numVertexes, &G->numEdges);       /*输入顶点数和边数*/
    for(i = 0; i< G->numVertexes; i++)
    {
        scanf("输入顶点信息: %d",&G->adjList[i].data);
        G->adjList[i].firstedge = NULL;                 /*将边表置为空表*/
    }

    for(k = 0; k< G->numEdges; k++)                     /*建立边表*/
    {
        printf("输入边(Vi,Vj)上的顶点序号:\n");
        scanf("%d,%d",&i,&j);                           /*输入边(Vi,Vj)上的顶点序号*/
        e = (EdgeNode *)malloc(sizeof(EdgeNode));       /*向内存申请空间，生成边表结点*/
        e->adjvex=j;                                    /*邻接序号为j*/
        e->next=G->adjList[i].firstedge;                /*将e指针指向当前顶点指向的结点*/
        G->adjList[i].firstedge = e;                    /*将e指针指向当前顶点指向的结点*/
        e = (EdgeNode *)malloc(sizeof(EdgeNode));       /*向内存申请空间，生成边表结点*/
        e->adjvex = i;                                  /*邻接序号为i*/
        e->next=G->adjList[j].firstedge;                /*将e指针指向当前顶点指向的结点*/
        G->adjList[j].firstedge = e;                    /*将当前顶点的指针指向e*/
    }

}
```

&emsp;&emsp;从申请空间开始的代码，是应用了我们在单链表创建中讲解的头插法。由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O(n+e)。  

### 7.3.3 十字链表  

&emsp;&emsp;对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可能把</b>邻接表与逆邻接表结合起来</b>呢？答案是肯定的，就是把它们整合在一起，这就是我们现在要江的有向图的一种存储方法：<b>十字链表(Orthogonal List)</b>。  
&emsp;&emsp;我们重新定义定点表结点结构如下所示：  

<table sysle="margin:0 auto;">
    <tr>
        <th>data</th>
        <th>firstin</th>
        <th>firstout</th>
    </tr>
</table>


&emsp;&emsp;其中firstin表示入边表头指针，指向该顶点的入表边中第一个结点，firstout表示出表头指针，指向该顶点的出表边中的第一个结点。  
&emsp;&emsp;重新定义的边表结点结构如下：  


<table sysle="margin:0 auto;">
    <tr>
        <th>tailvex</th>
        <th>headvex</th>
        <th>headlink</th>
        <th>taillink</th>
    </tr>
</table>

&emsp;&emsp;其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个wegiht域来存储权值。  
&emsp;&emsp;比如图7.23，顶点依然是存入一个一维数组{v~0~,v~1~,v~2~,v~3~},实线箭头指针的图示完全与图7.21的邻接表相同。就以顶点v~0~来说，firstout指向的是出边表中的第一个结点v~3~。所以v~0~边表结点的headvex=3，而tailvex其实就是当前顶点v~0~边表结点的下标0，由于v~0~只有一个出边顶点，所以headlink和taillink都是空。   

<div align="center"><img src="data_structure_image/7/7.23.png"></div>  

&emsp;&emsp;我们重点需要解释虚线箭头的含义，它其实就是此突的逆邻接表的表示。对于v~0~来说，它有两个顶点v~1~和v~2~的入边。因此v~0~的firstin指向顶点v~1~的边表结点中headvex为0的结点，如图7.23右图的1。接着由入边结点的headlink指向下一个入边顶点v~2~，如图2.对于顶点v~1~，它有一个入边顶点v~2~，所以它的finsitin指向顶点v~2~的边表结点中headvex为1的结点，如图中的3。顶点v~2~和v~3~也是同样有一个入边顶点，如图中4和5。  
&emsp;&emsp;十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以v~i~为尾的弧，也很容易找到以v~i~为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法时间复杂度和邻接表相同的，因此，在有向图中，十字链表是非常好的数据结构模型。  

### 7.3.4 邻接多重表 

&emsp;&emsp;讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？如果我们在无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注边的操作，比如对已访问国的边做标记，删除某一条边等操作，那就意味着，需要找到这条边的两个边表结点进行操作，这其实还是比较麻烦的。比如图7.24，若要删除左图的(v~0~,v~2~)这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较繁琐的。  

<div align="center"><img src="data_structure_image/7/7.24.png"></div>  

&emsp;&emsp;因此，我们也仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。  
&emsp;&emsp;重新定义的边表结点结构如表所示:  

<table sysle="margin:0 auto;">
    <tr>
        <th>ivex</th>
        <th>ilink</th>
        <th>jvex</th>
        <th>jlink</th>
    </tr>
</table>

&emsp;&emsp;其中<b>ivex和jvex是与某条边依附的两个顶点在顶点表中下标。ilink指向依附定点ivex的下一条边，jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构</b>。  


### 7.3.5 边集数组  

&emsp;&emsp;边集数组是由两个一维数组构成。一个存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成，如图7.25所示。显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。关于边集数组的应用后面在克鲁斯卡尔(Kruskal)算法中有介绍。  

<div align="center"><img src="data_structure_image/7/7.25.png"></div>  


## 7.4 图的遍历  

&emsp;&emsp;图的遍历是和树的遍历类似，我们需要<b>从图中某一顶点出发遍寻图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历(Traversing Graph)</b>。  
&emsp;&emsp;树的遍历我们谈到了四种方案，应该说都还好。毕竟根结点只有一个，遍历都是从它发起的，其余所有结点都只有一个双亲，可图就复杂多了，因为它的任一定点都可能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，而有些顶点却还没有遍历到的情况。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体方法是设置一个访问数组visited[n]，n是图中顶点的个数，初值为0，访问过后设置为1。  
&emsp;&emsp;对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是<b>深度优先遍历和广度优先遍历</b>。  
 
 ### 7.4.1 深度优先遍历  

&emsp;&emsp;深度优先遍历(Depth_First_Search)，也有被称为深度优先搜索，简称DFS。假设需要完成一个任务，要求7.26左图这样的一个迷宫中，从顶点A开始要走遍所有的图顶点并作上标记，注意不是简单地看着这样的平面图走，而是如同现实般地只有高墙和通道的迷宫中去完成任务。  

<div align="center"><img src="data_structure_image/7/7.26.png"></div>    

&emsp;&emsp;很显然我们是需要策略的，否则在这四通八达的通道中乱窜，要想完成任务那就只能碰运气。如果你学过深度优先遍历，这个任务就不难完成了。  
&emsp;&emsp;首先我们从顶点A开始，做上表示走过的记号后，面前有两条路，通向B和F，我们给自己定一个原则，在没有碰到重复顶点的情况下，始终是向右手边走，于是走到了B顶点。整个行路过程，可以参看图7.26的右图。此时发现有三条分支，分别通向顶点C、I、G，右手通行原则，使得我们走到了C顶点。就这样，我们一直顺着右手通道走，一直走到了F定点。当我们依然选择右手通道走过去之后，发现走回到顶点A了，因为在这里做了记号表示已经走过了。此时我们退回顶点F，走向从右数的第二条通道，到达了G顶点，它有三条通道，发现B和D都已经是走过的，于是走到H，当我们面对通向H的两条通道D和E时，会发现都已经走过了。  
&emsp;&emsp;此时我们是否已经遍历了所有顶点呢？没有，可能还有很多分支的顶点我们没有走到，所以我们按原路返回。在顶点H处，再无通道走过，返回到G，也无未走过通道，返回到F，没有通道，返回到E，有一条通往H的通道。验证后也是走过的，再返回顶点D，此时还有三条道未走过，一条条来，H走过了，G走过了，I这是一个新顶点，没有标记，记下来。继续返回，直到返回顶点A，确认你已经完成遍历所有任务，找到了所有的9个顶点。  
&emsp;&emsp;8反应快的同学一定会感觉到，深度优先遍历其实就是一个递归的过程。如果再敏感一些，会发现其实转换成如图7.26右图所示，就像是一棵树的前序遍历，没错，它就是。它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。  
&emsp;&emsp;如果我们用的是邻接矩阵的方式，则代码如下：  

```
typedef int Boolean;            /*Boolean 是布尔类型，其值是TRUE或FALSE*/
Boolean visited[MAX];           /*访问标志的数组*/

/*邻接矩阵的深度优先递归算法*/

void DFS(MGraph G, int i)
{
    int j;
    visited[i] = TRUE;
    printf("%c", G.vexs[i]);    /*打印顶点，也可以做其他操作*/
    for(j = 0; j < G.numVertexes; j++)
    {
        if(G.arc[i][j] == 1 && !visites[j])
        {
            DFS[G,j];           /*对访问的邻接顶点递归调用*/
        }
    }
}

/*邻接矩阵的深度遍历操作*/
void DFSTraverse(MGraph G)
{
    int i;
    for(i = 0; i<G.numVertexes; i++)
    {
        visited[i] = FALSE;     /*初始所有顶点状态都是来访问过状态*/
    }
    for( i = 0; i<G.numVertexes; i++)
    {
        if(!visited[i]) /*对未访问国的顶点调用DFS，若是连通图，指挥执行一次*/
        {
            DFS(G,i);
        }
    }
}
```

&emsp;&emsp;对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n~2~)的时间。而邻接表做存储结构时，找邻接点所需要的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。  
&emsp;&emsp;对于有图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的。  


### 7.4.2 广度优先遍历


&emsp;&emsp;广度优先遍历(Breadth_First_Search)，又称为广度优先搜索，简称BFS。如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图7.26的第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层，如图7.27的第二幅图所示。此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。  

<div align="center"><img src="data_structure_image/7/7.26.png"></div>    

&emsp;&emsp;有了这个讲解，我们来看代码就非常容易了。以下是邻接矩阵结构的广度优先遍历算法。  

```
/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G)
{
    int i, j;
    Queue Q;
    for(i = 0; i < G.numVertexes; i++)
    {
        visited[i] = FALSE;
    }
    InitQueue(&Q);                      /*初始化一辅助用的队列*/
    for(i = 0; i < G.numVertexes; i++)  /*对每一个顶点做循环*/
    {
        if(!visited[i])                 /*若是未访问就处理*/
        {
            visited[i] = TRUE;          /*设置当前顶点访问过*/
            printf("%c",G.vexs[i]);     /*打印顶点，也可以其他操作*/
            EnQueue(&Q,i);              /*将此顶点入队列*/
            while(!QueueEmpty(Q))       /*若当前队列不为空*/
            {
                DeQueue(&Q,&i);         /*将队中元素出队列，赋值给i*/
                for(j = 0; j < G.numVertexes; j++)
                {
                    /*判断其他顶点若与顶点存在且未访问过*/
                    if(G.arc[i][j] == 1 && !visited[j])
                    {
                        visited[j] = TRUE;  /*将找到的此顶点标记为标记已访问*/
                        printf("%c",G.vexs[j]); /*打印顶点*/
                        EnQueue(&Q,j);          /*将找到的此顶点入队列*/
                    }
                }
            }
        }
    }
}
```

&emsp;&emsp;对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下:  

```
/*邻接表的广度遍历算法*/
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;
    Queue Q;
    for(i = 0; i< GL->)
    {
        visited[i] = FALSE;
    }
    InitQueue(&Q);
    for(i = 0; i < GL->numVertexes; i++)
    {
        if(!visited[i])
        {
            visited[i] = TRUE;
            printf("%c",GL->adjList[i].data);   /*打印顶点，也可以是其他操作*/
            EnQueue(&Q,i);
            while(!QueueEmpty(Q))
            {
                DeQueue(&Q,&i);
                p = GL->adjList[i].firstedge;   /*若此顶点未被访问*/
                {
                    visited[p->adjvex] = TRUE;
                    printf("%c",GL->adjList[p->adjvex].data);
                    EnQueue(&Q,p->adjvex);      /*将此顶点入队列*/
                }
                p = p->next;                /*指针指向下一个邻接点*/
            }
        }
    }
}
```

&emsp;&emsp;对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分，只是视不同的情况选择不同的算法。  
&emsp;&emsp;不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就需要仔细斟酌。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。  


## 7.5 最小生成树  

&emsp;&emsp;现在需要为一个镇的9个村庄架设通信网络做设计，村庄位置大致如图7.28所示，其中v~0~至v~8~是村庄，之间连线的数字表示村与村之间的可通达的直线距离，比如v~0~至v~1~就是10公里。现要求用最小的成本完成这次任务。  

<div align="center"><img src="data_structure_image/7/7.28.png"></div>    

&emsp;&emsp;显然这是一个带权值的图，即网结构。所谓的最小成本，就是n个顶点，用n-1条边把一个连通图连接起来，并且使得权值的和最小。在这个例子中，每多一公里就多一份成本，所以只要让线路连线的公里数最少，就是最少成本。有没有什么办法可以很精确计算出这种网图的最佳方案呢？  
&emsp;&emsp;我们在讲图的定义和术语时，曾经提到过，一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。那么我们把这种<b>构造连通网的最小代价生成树称为最小生成树(Minimum Cost Spanning Tree)</b>。找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。  

### 7.5.1 普里姆(Prim)算法  

&emsp;&emsp;为了能讲明白这个算法，我们先构造图7.28的邻接矩阵，如图7.29的右图所示。  

<div align="center"><img src="data_structure_image/7/7.29.png"></div>    

&emsp;&emsp;也就是说，现在我们已经有了一个存储结构为MGraph的G。G有个9顶点，它的arc二维数组如图7.29的右图所示。数组中我们用65535来代表无穷大。  
&emsp;&emsp;于是普里姆(Prim)算法代码如下，左侧数字为行号。其中INFINITY为权值极大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看它是如何运行并打印最小生成树的。  

```
/*Prim 算法生成最小生成树 */
void MiniSpanTree_Prim(MGraph G)
{
    int min, i, j, k;
    int adjvex[MAXVEX];          /*保存相关顶点下标*/
    int lowcost[MAXVEX];         /*保存相关顶点间边的权值*/
    lowcost[0] = 0;              /*初始化第一个权值为0，即v0加入生成树*/
                                 /*lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/
    adjvex[0] = 0;               /*初始化第一个顶点下标为0*/
    for(i = 1; i < G.numVertexes; i++)
    {
        lowcost[i] = G.arc[0][i];/*将v0顶点与之有边的权值存入数组*/
        adjvex[i] = 0;           /*初始化都为v0的下标*/
    }

    for(i = 1; i < G.numVertexes; i++)
    {
        min = INFINITY;          /*初始化最小权值为最大值*/
                                 /*通常设置为不可能的大数字如32767、65535等*/
        j = 1;
        k = 0;
        while(j < G.numVertexes)/*循环全部顶点*/
        {
            if(lowcost[j] != 0 && lowcost[j] < min)
            {
                /*如果权值不为0且权值小于min*/
                min = lowcost[j];/*则让当前权值成为最小值*/
                k = j;           /*将当前最小值的下标存入k*/
            }
            j++;
        }

        printf("(%d,%d)", adjvex[k],k); /*打印当前顶点边中权值最小边*/
        lowcost[k] = 0;           /*将当前顶点的权值设置0，表示此顶点已经完成任务*/
        for(j = 1; j < G.numVertexes; j++) /*循环所有顶点*/
        {
            if(lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
            {
                /*若下标为k顶点各边权值小于这些顶点未被加入生成树权值*/
                lowcost[j] = G.arc[k][j];   /*将较小权值存入lowcost*/
                adjvex[j] = k;              /*将下标为k的顶点存入adjvex*/
            }
        }
    }
}
```

&emsp;&emsp;程序开始运行，由4～5行创建了两个一维数组lowcost和adjvex，长度都为顶点个数9。它们的作用我们慢慢细说。6～7行然后分别给这两个数组的第一个下标位赋值为0，arjvex[0]=0其实意思就是我们现在从顶点v0开始(事实上，最小生成树从哪个顶点开始计算都无所谓，假如从v0开始)，lowcost[0]=0就表示此下标的顶点被纳入最小生成树。8～12行表示我们读取图7.29的右图邻接矩阵的第一行数据。将数值赋值给lowcost数组，所以此时lowcost数组值为{0,10,65535,65535,65535,11,65535,65535,65535}，而arjvex则全部为0。此时，我们已经完成了整个初始化的工作，准备开始生成。  
&emsp;&emsp;第13~36行，整个循环过程就是构造最小生成树的过程。第15～16行，将min设置为了一个极大值655 35，它的母的是为了之后找到一定范围内的最小权值。j是用来做顶点下标循环的变量，K是用来存储最小权值的顶点下标。  
&emsp;&emsp;第17～25行，循环中不断修改min为当前lowcoast数组中最小值，并用k保留此最小值的顶点下标。经过循环后，min=10，k=1。注意19行if判断的lowcost[j]!=0表示已经是生成树的顶点不参与最小权值的查找。  
&emsp;&emsp;第26行，因k=1，adjvex[1]=0，所以打印结果为(0,1)，表示V~0~至v~1~边为最小生成树的第一条边。如图7.30所示:

<div align="center"><img src="data_structure_image/7/7.30.png"></div>    

&emsp;&emsp;第27行，此时因k=1我们将lowcost[k]=0就是说顶点v~1~纳入到最小生成树中。此时lowcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}。 
&emsp;&emsp;第28～35行，j循环由1至8，因k=1，查找邻接矩阵的第v~1~行的各个权值，与lowcoast的对应值比较，若更小则修改lowcost值，并将k值存入adjvex数组中。因第v~1~行有18、16、12均比65535小，所以最终lowcost数组的值为：{0,0,18,65535,65535,11,16,65535,12}。adjvex数组的值为:{0,0,1,0,0,0,1,0,1}。这里第30行if判断的lowcost[j]!=0也说明v~0~和v~1~已经是生成树的顶点不参与最小权值的比对了。 
&emsp;&emsp;再次循环，由第15行到第26行，此时min=11.k=5,adjvex[5]=0。因为打印结构为(0,5)。表示v~0~至v~5~边为最小生成树的第二条边，如图7.31所示。  

<div align="center"><img src="data_structure_image/7/7.31.png"></div>    

&emsp;&emsp;接下来执行到36行，lowcost数组的值为:{0,0,18,65535,26,0,16,65535,12}。adjvex数组的值为：{0,0,1,0,5,0,1,0,1}。  
&emsp;&emsp;之后，相信大家也都会自己去模拟了。通过不断的转换，构造的过程如图7.32中图1～图6所示。  

<div align="center"><img src="data_structure_image/7/7.32.png"></div>    

&emsp;&emsp;有了这样的讲解，再来介绍普里姆(Prim)算法的实现定义可能就容易理解一些。假设N=(P,{E})是连通网，TE是N上最小生成树中边的集合。算法从U={u~0~}(u~0~$\in$V)，TE={}开始。重复执行下述操作：在所有u$\in$U，v$\in$V-U的边(u,v)$\in$E中找一条代价最小的边(u～0~,v~0~)并入集合TE，同时v~0~并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树。由于算法代码中的循环嵌套可得知此算法的时间复杂度为O(n^2^)。  

### 7.5.2 克鲁斯卡尔(Kruskal)算法  

&emsp;&emsp;现在我们来换一种思考方式，普里姆(Prim)算法是以某顶点为起点，逐步找顶点山最小权值的边来构建最小生成树的。这就像是我们如果去参考某个展会，例如世博会，你从一个入口进去，然后找你所在位置周边的场馆中你最感兴趣的场馆观光，看完后再用同样的办法看下一个。可我们为什么不事先计划好，进园后直接到你最想去看的场馆观看呢？事实上，去世博园的观众，绝大多数都是这样做的。  
&emsp;&emsp;同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边数集结构。以下是edge边集数组结构的定义代码：  
```
/*对边集数组Edfe结构的定义*/
typedef struct
{
    int begin;
    int end;
    int weight;
}Edge;
```
&emsp;&emsp;我们将之前的邻接矩阵通过转换为图7.33的右图的边集数组，并且对它们按权值从小到大排序。  

<div align="center"><img src="data_structure_image/7/7.33.png"></div>    

&emsp;&emsp;于是克鲁斯卡尔(Kruskal)算法代码如下，其中MAXEDGE为边数量的最大值，此处大于等于15即可，MAXVEX为定点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入图7.33右图的邻接矩阵后，看看它是如何运行并打印最小生成树的。  

```
/*Kruskal算法生成最小生成树*/
void MiniSpanTree_Kruskal(MGraph G) /*生成最小生成树*/
{
    int i, n, m;
    Edge edges[MAXEDGE];    /*定义边集数组*/
    int parent[MAXVEX];     /*定义一维数组用来判断边与边是否形成回路*/
    /*此处将省略将邻接矩阵G转换为边集数组edges并按权由小到大排序*/
    for(i = 0; i < G.numVertexes; i++)
    {
        parent[i] = 0;      /*初始化数组值为0*/
    }
    for(i = 0; i<G.numEdges; i++)   /*循环每一条边*/
    {
        n = Find(parent, edges[i].begin);
        m = Find(parent, edges[i].end);
        if(n != m)          /*假如n与m不等，说明此边没有与现有生产树形成环路*/
        {
            parent[n] = m;  /*将此边的结尾顶点放入下标起点的parent中*/
                            /*表示此顶点已经存在生成树集合中*/
            printf("(%d,%d) %d",edges[i].begin,edges[i].end,edges[i].weight);
        }
    }
}

int Find(int *parent, int f)/*查找连线顶点的尾部下标*/
{
    while(parent[f] > 0)
    {
        f = parent[f];
    }
    return f;
}
```

&emsp;&emsp;程序开始运行，第5行之后，我们省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，在第5行开始，我们已经有了结构为edge，数据内容是图7.33的右图的一维数组edges。  
&emsp;&emsp;第5～7行，我们声明一个数组parent，并将它的值都初始化为0，第8～17行，我们开始对边集数组做循环遍历，开始时，i=0。第10行，我们调用了第19～25行的函数Find，传入的参数是数组parent和当前权值最小边(v~4~,v~7~)的begin:4。因为parent中全都是0所以传出值使得n=4。  
&emsp;&emsp;第11行，传入(v~4~,v~7~)的end:7。传出值使得m=7。第12～16行，很显然n与m不相等，因此parent[4]=7。此时parent数组值为{0,0,0,0,7,0,0,0,0}，并且打印得到"(4,7) 7"。此时我们将边(v~4~,v~7~)纳入到最小生成树中，如图7.34所示:  

<div align="center"><img src="data_structure_image/7/7.34.png"></div>    

&emsp;&emsp;循环返回，执行10～16行，此时i=1，edge[1]得到边(v~2~,v~8~)，n=2，m=8，parent[2]=8，打印结果为"(2,8) 8"，此时parent数组值为{0,0,8,0,7,0,0,0,0}，这也就表示边(v~4~,v~7~)和边(v~2~,v~8~)已经纳入到最小生成树，如图7.35所示。

<div align="center"><img src="data_structure_image/7/7.35.png"></div>    

&emsp;&emsp;再次执行10～16行，此时i=2，edge[2]得到边(v~0~,v~1~)，n=0，m=1，parent[0]=1,打印结果为"(0,1) 10"，此时parent数组值为{1,0,8,0,7,0,0,0,0}，此时边(V~4~,v~7~)、(v~2~,v~8~)和(v~0~,v~1~)已经纳入到最小生成树，如图7.36所示：  

<div align="center"><img src="data_structure_image/7/7.36.png"></div>    

&emsp;&emsp;当i=3、4、5、6时，分别将边(v~0~,v~5~)、(v~1~,v~8~)、(v~3~,v~7~)、(v~1~,v~6~)纳入最小生成树中，如图7.37所示。此时parent数组值为{1,5,8,7,7,8,0,0,6}，怎么去解读这个数组现在这些数字的意义呢？  

<div align="center"><img src="data_structure_image/7/7.37.png"></div>    

&emsp;&emsp;从图7.37的最右图i=6的粗线连线可以得到，我们其实是有两个连通的边集合A与B中纳入到最小生成树中，如图7.38所示。当parent[0]=1，表示v~0~和v~1~已经在生成树的边集合A中，parent[5]=8表示v~5~与v~8~在边集合A中，parent[8]=6表示v~8~与v~6~在边集合A中，parent[6]=0表示集合A暂时到头，此时边集合A有v~0～、v~1~、v~5~、v~8~、v~6~。我们查看parent中没有查看的值，parent[2]=8表示v~2~与v~8~在一个集合中，因此v~2~也在边集合A中。再由parent[3]=7、parent[4]=7和parent[7]=0可知v~3~,v~4~,v~7~在另一个边集合B中。  

<div align="center"><img src="data_structure_image/7/7.38.png"></div>    

&emsp;&emsp;当i=7时，第10行，调用Find函数，会传入参数edges[7].begin=5。此时第21行，parent[5]=8>0，所以f=8，再循环得parent[8]=6。因parent[6]=0所以Find返回后第10行得到n=6。而此时第11行，传入参数edges[7].end=6得到m=6.此时n=m，不再打印，继续下一循环。这就告诉我们，因为边(v~5~,v~6~)使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如图7.38所示。  
&emsp;&emsp;当i=8时，与上面相同，由于边(v~1~,v~2~)使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如图7.38所示。  
&emsp;&emsp;当i=9时，边(v~6~,v~7~)，第10行得到n=6，第11行得到m=7，因此parent[6]=7，打印"(6,7) 19".此时parent数组值为{1,5,8,7,7,8,0,6}如图7.39所示。此后边的循环均造成环路，最终最小生成树如下所示：  

<div align="center"><img src="data_structure_image/7/7.39.png"></div>    

&emsp;&emsp;假设N=(V,{E})是连通网，则令最小生成树的初始化状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。  
&emsp;&emsp;此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次。所以克鲁斯卡尔算法的时间复杂度为O(eloge)。对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，则边数非常多的情况会更好一些。  

## 7.6 最短路径  

&emsp;&emsp;在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是两顶点之间经过的边数最少的路径；而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。  

### 7.6.1 迪杰斯特拉(Dijkstra)算法

&emsp;&emsp;这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。  
&emsp;&emsp;比如说要求图7.40中顶点v~0~到顶点v~1~的最短路径，没有比这更简单的了，答案就是直接v~0~连线到v~1~。  

<div align="center"><img src="data_structure_image/7/7.40.png"></div>    

&emsp;&emsp;由于顶点v~2~还与v~4~、v~5~连线，所以此时我们同时求得了v~0~->v~2~->v~4~其实就是v~0~->v~1~->v~2~->v~4~=4+1=5，v~0~->v~2~->v~5~=4+7=11。这里v~0~->v~2~我们用的是刚才计算出来的较小的4。此时我们也发现v~0~->v~1~->v~2~->v~4~=5要比v~0~->v~1~->v~4~=6还要小。所以v~0～到v~4~目前的最小距离是5，如图7.41所示：  

<div align="center"><img src="data_structure_image/7/7.41.png"></div>    

&emsp;&emsp;当我们要求v~0~到v~3~的最短距离时，通向v~3~的三条边，除了v~6~没有研究过外,v~0~->v~1~->v~3~的结果是8，而v~0~->v~4~->v~3~=5+2=7。因此，v~0~到v~3~的最短距离是7，如图7.42所示：  

<div align="center"><img src="data_structure_image/7/7.42.png"></div>    

&emsp;&emsp;这个迪杰斯特拉(Dijkstra)算法并不是一下子就求出了v~0~到v~8~的最短路径，而是一步步求出它们之间的顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到想要的结果。  

```
#define INFINITY 65535

typedef int Pathmatirx[MAXVEX];     /*用于存储最短路径下标的数组*/

typedef int ShortPathTable[MAXVEX]; /*用于存储到各点最短路径的权值和*/

/*Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径p[v]及带权长度D[v]*/
/*P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和*/

void ShortestPath_Dijkstra(MGraph G, int v0, Pathmatirx *P, ShortPathTable *D) 
{
    int v,w,k,min;
    int final[MAXVEX];  /*final[w] = 1 表示求得顶点v0至Vw的最短路径*/
    for(v=0;v < G.numVertexes; v++)/*初始化数据*/
    {
        final[v] = 0;               /*全部顶点初始化为未知最短路径状态*/
        (*D)[v] = G.matrix[v0][v];  /*将与v0点有连线的顶点加上权值*/
        (*p)[v] = 0;                /*初始化路径数组P为0*/
    }
    (*D)[v0] = 0;                   /*v0至v0路径为0*/
    final[v0] = 1;                  /*v0至v0不需要求路径*/
    /*开始主循环，每次求得v0到某个v顶点的最短路径*/
    for(v=1; v<G.numVertexes; v++)
    {
        min = INFINITY;             /*当前所知离v0顶点的最短距离*/
        for(w=0; w<G.numVertexes;w++)   /*寻找离v0最近的顶点*/
        {
            if(!final[w] && (*D)[w] < min)
            {
                k = w;
            	min = (*D)[w];           /*w顶点离v0顶点更近*/s
            }
        }
    	final[k] = 1;                   /*将目前找到的最近的顶点置为1*/
    	for(w=0; w<G.numVertexes; w++)  /*修正当前最短路径及距离*/
    	{
        	/*如果经过v顶点的路径比现在这条路径的长度短的话*/
        	if(!final[w] && (min+G.matirx[k][w] < (*D)[w]))
        	{
            	/*说明找到了更短的路径，修改D[w]和P[w]*/
            	(*D)[w] = min+G.matirx[k][w]; /*修改当前路径长度*/
            	(*p)[w] = k;
        	}
    	}
    }
}
```

&emsp;&emsp;调用此函数前，其实我们需要为图7.43的左图准备邻接矩阵MGraph的G，如图7.43的右图，并定义参数v0为0。  

<div align="center"><img src="data_structure_image/7/7.43.png"></div>    

1. 程序开始运行，第4行final数组是为了v~0~到顶点是否已经求得最短路径的标记，如果v0到vw已经有了结果，则final[w]=1。  
2. 第5~10行，是在对数据进行初始化的工作。此时final数组值均为0，表示所有的点都未求得最短路径。D数组为{65535,1,5,65535,65535,65535,65535,65535,65535}。因为v~0~与v~1~和v~2~的边权值为1和5。P数组全为0，表示目前没有路径。  
3. 第11行，表示v~0~到v~0~自身，权值和结果为0.D数组为{0,1,5,65535,65535,65535,65535,65535,65535}。第12行，表示v0点算是已经求得最短路径，因为final[0]=1.此时final数组为{1,0,0,0,0,0,0,0,0}。此时整个初始化工作完成。  
4. 第13～33行，为主循环，每次循环求得v0与一个顶点的最短路径。因为v从1而不是0开始。  
5. 第15～23行，先令min为65535的极大值，通过w循环，与D[w]比较找到最小值min=1，k=1。  
6. 第24行，由k=1，表示与v~0~最近的顶点是v~1~，并且由D[1]=1，知道此时v~0~到v~1~最短距离是1。因此将v1对应的final[1]设置为1。此时final数组为{1,1,0,0,0,0,0,0}。  
7. 第25行～32行是一循环，此循环是关键。它的目的是在刚才已经找到v~0~与v~1~的最短路径的基础上，对v~1~与其他顶点的边进行计算，得到v~0~与它们的当前最短据林，如图7.44所示。因为min=1，所以本来D[2]=5，现在v~0~->v~1~->v~2~=D[2]=min+3=4,v~0~->v~1~->v~3~=D[3]=min+7=8,v~0~->v~1~->v~4~=D[4]=min+5=6,因此，D数组当前值为{0,1,4,8,6,65535,65535,65535,65535}。而P[2]=1,P[3]=1,P[4]=1，它表示的意思是v~0~到v~2~、v~3~、v~4~点的最短路径它们的前驱均是v~1~。此时P数组值为:{0,0,1,1,1,0,0,0,0}。  

<div align="center"><img src="data_structure_image/7/7.44.png"></div>    

- 弗洛伊德(Floyd)算法(任意两点)

```C
#define MAXVEX 9
#define INFINITY 65535
typedef int Pathmatirx[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];
/*Floyd算法，求网图G中各个顶点v到其余顶点w最短路径p[v][w]及带权长度D[v][w]*/

void ShortestPath_Floayd(MGraph G, Pathmatirx *p, ShortPathTable *D)
{
    int v, w, k;
    for(v = 0; v < G.numVertexes;++v)	/*初始化D与p*/
    {
        for(w = 0; w < g.numVertexes; ++w)
        {
            (*D)[v][w] = G.matirx[v][w];/*D[v][w]值即为对应点间的权值*/
            (*p)[v][w] = w;				/*初始化P*/
        }
    }
    
    // k代表的是中转顶点的下标,v代表的是起始顶点，w代表结束顶点
    for(k = 0; k < G.numVertexes; ++k)
    {
        for(v = 0; v < G.numVertexes; ++v)
        {
            for(w = 0; w < G.numVertexes; ++w)
            {
                if((*D)[v][w] > (*D)[v][k]+(*D)[k][w])
                {
                    /*如果经过下标为k顶点路径比原亮点间路径更短*/
                    /*将当前两点间权值设为更小的一个*/
                    (*D)[v][w] = (*D)[v][k] + (*D)[k][w];
                    (*p)[v][w] = (*p)[v][k];/*路径设置经过下标为k的顶点*/
                }
            }
        }
    }
}

//求最短路径的显示代码，得到p数组后

void showShortPath(){
    int v, w, k;
    for(v = 0; v < G.numVertexes; w++)
    {
    	printf("v%d-v%d weight:%d ", v,w,D[v][w]);
        k = P[v][w]; /*获取低一个路径顶点下标*/
        printf(" path: %d", v);/*打印源点*/
        while(k != w)/*如果路径顶点下标不是终点*/
        {
            printf(" -> %d", k);/*打印路径顶点*/
            k = p[k][w];		/*获取下一个路径顶点下标*/
        }
        printf(" -> %d \n", w);
    }
    printf("\n");
}
```
&emsp;&emsp;这里用到二维数组，p[v][w]表示从v顶点到w顶点的最短路径，D[v][w]表示v顶点到w顶点的最短路径长度。满足D0[v][w] = min{D-1[v][w], d-1[v][0]+D-1[0][w]}。

### 7.6.2 拓扑排序介绍

&emsp;&emsp;在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network)。设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V~0~、V~1~、...、V~n~，满足若从顶点v~i~到v~j~有一条路径，则在顶点序列中顶点v~i~必在顶点v~j~之前。则我们称这样的顶点序列为拓扑序列。  

- 数据结构

```C
typedef struct EdgeNode	/*边表结点*/
{
    int adjvex;			/*邻接点域，存储该顶点对应的下标*/
    int weight;			/*用于存储权值*/
    struct EdgeNode *next;/*lian*/
}EdgeNode;

typedef struct VertexNode	/*顶点表结点*/
{
    int in;					/*顶点入度*/
    int data;				/*顶点域，存储顶点信息*/
    EdgeNode *firstedge;	/*边表头指针*/
}VertexNode, AdjList[MAXVEX];

typedef struct
{
    AdjList adjList;
    int numVertexes, numEdges;/*图中当前顶点数和边数*/
}graphAdjList,*GraphAdList;
```

- 拓扑排序算法

```C
/*拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK,若有回路返回ERROR*/

Status TopologicalSort(GraphAdjList GL)
{
    EdgeNode *e;
    int i,k,gettop;
    int top = 0;/*用于栈指针下标*/
    int count = 0;/*用于统计输出顶点的个数*/
    int *stack;/*建栈存储入度为0的顶点*/
    stack  = (int *)malloc(GL->numVertexes * sizeof(int));
    for(i = 0; i < GL->numVertexes; i++)
    {
        if(GL->adjList[i].in == 0)
        {
            stack[++top] = i;/*将入度为0的顶点入栈*/
        }
        
        while(top != 0)
        {
            gettop = stack[top--];/*出栈*/
            printf("%d ->", GL->adjList[gettop].data);/*打印此顶点*/
            count++;/*统计输出项点数*/
            for(e = GL->adjList[gettop].firstedge;e; e = e->next)
            {
                /*对此顶点弧表遍历*/
                k = e -> adjvex;
                if(!(-- GL->adjList[k].in))/*将k号顶点邻接点的入度减1*/
                {
                    stack[++top] = k;/*若为0则入栈，以便于下次循环输出*/
                }
            }
        }
        
        if(count < GL->numVertexes)/*如果count小于顶点数，说明存在环*/
        {
            return ERROR;
        }else
        {
            return OK;
        }
    }
}

```

### 7.6.3 关键路径

&emsp;&emsp;在一个表示工程的带权有向图中，用顶点表示事件，用有边表示活动，用边上的权值表示活动的持续事件，这种有向图的边表示活动的网，我们称为AOE网(Activity On Edge Network)。路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。

&emsp;&emsp;定义如下参数：

- 事件的最早发生时间etv(earliest time of vertex):即顶点Vk的最早发生时间。
- 事件的最晚发生时间ltv(latest time of vertex):即顶点Vk的最晚发生时间。
- 活动的最早开工时间ete(earliest time of edge):即活动Ak的最早开工时间。
- 活动的最晚开工时间lte(latest time of edge):即活动Ak的最晚开工时间。

&emsp;&emsp;首先是对拓扑排序算法增加几行代码，求出stack2,etv数组和top2。

```C
int *etv,*ltv; /* 事件最早发生时间和最迟发生时间数组*/
int *stack2;/*用于存储拓扑序列的栈*/
int top2;/*用于stack2的指针*/

/*拓扑排序，用于关键路径计算*/

Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
    int i,k,gettop;
    int top = 0;/*用于栈指针下标*/
    int count = 0;/*用于统计输出顶点的个数*/
    int *stack;/*间栈将入度为0的顶点入栈*/
    
    stack = (int *)malloc(GL->numVertexes * sizeof(int));
    for(i = 0; i < GL->numVertexes; i++)
    {
        if(0 == GL->adjList[i].in)
        {
            stack[++top] = i;
        }
        
        top2 = 0; /*初始化为0*/
        etv = (int *)malloc(GL->numVertexes * sizeof(int));
        for(i = 0; i < GL->numVertexes;i++)
        {
        	etv[i] = 0; /*初始化为0*/   
        }
        stack2 = (int *)malloc(GL->numVertexes * sizeof(int));
        
        while(top != 0)
        {
            gettop = stack[top--];
            count++;
            
            stack2[++top2] = gettop;/*将弹出的顶点序号压入拓扑序列的栈*/
            
            for(e = GL->adjList[gettop].firstedge;e;e = e.next)
            {
                k = e->adjvex;
                if(!(--GL->adjList[k].in))
                {
                    stack[++top] = k;
                }
                
                if(etv[gettop] + e->weight > etv[k])/*求各顶点事件最早发生时间值*/
                {
                    etv[k] = etv[gettop] + e->weight;
                }
            }
        }
    }
}
```

&emsp;&emsp;求关键路径的算法代码：

```C
/*求关键路径，GL为有向网，输出GL的各项关键活动*/
void CriticalPath(GraphAdjList GL)
{
    EdgeNode *e;
    int i, k, j, gettop;
    int ete,lte;/*两个活动最早最晚发生时间变量*/
    TopologicalSort(GL);/*求拓扑序列，计算数组etv和stack2的值*/
    
    ltv = (int *)malloc(GL->numVertexes * sizeof(int));/*事件最晚发生时间*/
    for(i = 0; i < GL->numVertexes; i++)
    {
        ltv[i] = etv[GL->numVertexes - 1];/*初始化ltv*/
    }
    
    while(top2 != 0)/*计算ltv*/
    {
        gettop = stack2[top2--];/*将拓扑序列出栈，后进先出*/
        for(e = GL->adjList[gettop].firstedge;e;e = e->next)
        {
            /*求各顶点事件的最迟发生时间ltv值*/
            k = e->adjvex;
            if(ltv[k] - e->weight < ltv[gettop])/*求各顶点事件最晚发生时间ltv*/
            {
                ltv[gettop] = ltv[k] - e->weight;
            }
        }
    }
    
    for(j = 0; j < GL->numVertexes; j++)/*求ete,lte和关键活动*/
    {
        for(e = GL->adjList[j].firstedge; e; e = e->next)
        {
            k = e->adjvex;
            ete = etv[j];/*活动最早发生时间*/
            lte = ltv[k] - e->weight;/*活动最迟发生时间*/
            if(ete == lte)/*两者相等即在关键路径上*/
            {
                printf("<v%d,v%d> length: %d, ", GL->adjList[j].data, GL->adjList[k].data, e->weight);
            }
        }
    }
}
```

## 7.7 总结

- 图的存储结构
  - 邻接矩阵
    - 十字链表
  - 邻接表
    - 邻接多重表 
  - 边集数组

&emsp;&emsp;其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还链表存储的。十字链表是邻接矩阵的一种升级，而邻接多重表是邻接表的升级。通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵更合适，反之，用邻接表更合适。

- 最小生成树
  - 普里姆(Prim) 算法和克鲁斯卡尔(Kruskal) 算法

- 最短路径
  - 迪杰斯特拉(Dijkstra) 算法
  - 弗洛伊德(Floyd) 算法

- 有向无环图
  - 拓扑排序
  - 关键路径

&emsp;&emsp;确实自己写的笔记不过好看，不过上心，但是总的需要自己去做。