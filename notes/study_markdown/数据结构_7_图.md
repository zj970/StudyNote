# 7. 图  

## 7.1 图的定义 

&emsp;&emsp;在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中的多个元素相关，但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。可现实中，人与人之间关系就非常复杂，比如我认识的朋友，可能他们之间也互相认识，这就不是简单的一对一、一对多，研究人际关系很自然会考虑多对多的情况。那就是图。图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意，图中任意两个数据元素之间都可能相关（如图7.1）。  

<div align="center"><img src="data_structure_image/7/7.1.png"></div>

> 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

&emsp;&emsp;对于图的定义，我们需要明确几个注意的地方

- 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。  
- 线性表中可以没有数据元素，称为空表。书中可以没有结点，叫做空树。那么对于图呢？在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<b>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，</b>边集可以是空的。  

### 7.1.1 各种图定义  

&emsp;&emsp;<b>无向边：若顶点V~i~到V~j~之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(V~i~,V~j~)来表示。</b>如果图中任意两个顶点之间的边都是无向边，则称该图为无向边(Undirected graphs)。图7.2左图就是一个无向图，由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D)，也可以写成(D,A)。  
&emsp;&emsp;对于图7.2左图的无项图G~1~来说，G~1~ = (V~1~,{E~1~})，其中顶点集合V~1~={A,B,C,D};边集合E~1~={(A,B),(B,C),(C,D),(D,A),(A,C)}  

<div align="center"><img src="data_structure_image/7/7.2.png"></div>

&emsp;&emsp;<b>有向边：若从顶点V~i~到V~j~的边有方向，则称这条边为有向边，也称为弧(Arc)</b>。用有序偶<V~i~,V~j~>来表示，V~i~称为弧尾(Tail)，V~j~称为弧头(Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图(Directed graphs)。图7.2右图就是一个有向图。<b>连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A,D>表示弧，注意不能写成<D,A>。<b/>  

&emsp;&emsp;对于图7.2右图中的有向图G~2~来说，G~2~=(V~2~,{E~2~})，其中顶点集合V~2~={A,B,C,D}；弧集合E~2~={<A,D>,<B,A>,<C,A>,<B,C>}。<b>无向边用小括号“（）”表示，而有向边则是用尖括号“<>”表示</b>。  
&emsp;&emsp;<b>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</b>  
&emsp;&emsp;<b>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</b>含有n个顶点的无向完全图有n*(n-1)/2条边。比如图7.3就是无向完全图，因为每个顶点都要与除它以外的顶点连线，顶点A与BCD三个顶点连线，共有4个顶点，从4个选出两个进行匹配就是C${ n \choose 2}$，如图7.3所示：  

<div align="center"><img src="data_structure_image/7/7.3.png"></div>

&emsp;&emsp;<b>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</b>含有n个顶点的有向完全图有n*(n-1)条边，如图7.4所示：  

<div align="center"><img src="data_structure_image/7/7.4.png"></div>  

&emsp;&emsp;从这里也可以得到结论，对于具有n个顶点和e条边数的图，无向图0<e<=(n-1)/2，有向图0<e<=n(n-1)  
&emsp;&emsp;<b>有很少条边或弧的图称为稀疏图，反之称为稠密图。</b>有些图的边或弧具有与它相关的数字，这种<b>与图的边或弧相关的数叫做权(Weight)。</b>这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种<b>带权的图通常为网(Network)</b>。图7.5所示就是一张带权的图，即标识中国四大城市的直线距离的网，此图中的权就是两地的距离。  

<div align="center"><img src="data_structure_image/7/7.5.png"></div>  

&emsp;&emsp;<b>假设有两个图G=(V,{E})和G'=(V,{E}),如果V'$\subseteq$V且E'$\subseteq$E，则称G'为G的子图(Subgraph)。</b>如图7.6所示:  

<div align="center"><img src="data_structure_image/7/7.6.png"></div>

### 7.1.2 图的顶点与边间关系  
&emsp;&emsp;<b>对于无向图G=(V,{E}),如果边(v,v')$\in$E，则称顶点v和v'互为邻接点(Adjacent)，即v和v'相邻接。边(v,v')依附(incident)于顶点v和v'，或者说(v,v')与顶点v和v'相关联。顶点v的度(Degree)是和v相关联的边的数目，记为TD(v)</b>。例如图7.6左侧上方的无向图，顶点A与B互为邻接点，边(A,B)依附于顶点A与B上，顶点A的度为3.而此图的边数是5，各个顶点度的和=3+2+3+2=10，推敲后发现，边数其实就是各顶点度数和的一半，多出的一半是因为重复两次记数。简记之，<font color=red>e=1/2$\sum_{i=1}^n$TD(v~i~)</font>。  
&emsp;&emsp;<b>对于有向图G=(V,{E}),如果弧<v,v'>$\in$E，则称顶点v邻接到顶点v'，顶点v'邻接自顶点v。弧<v,v'>和顶点v,v'相关联。以顶点v为开头的弧的数目称为v的入度(InDegree)，记作ID(v)；以v为尾的弧的数目称为v的出度(OutDegree)，记为OD(v)；顶点v的度为TD(v) = ID(v) + OD(v)。例如图7.6左侧下方的有向图，顶点A的入度是2(从B到A的弧，从C到A的弧)，出度是1(从A到D的弧)，所以顶点A的度为2+1=3。此有向图的弧有4条，而各顶点的出度和=1+2+1+0=4，各顶点的入度和=2+0+1+1=4.所以得到<font color=red>e= $\sum_{i=1}^n$ID(v~i~) = $\sum_{i=1}^n$OD(v~i~)。</font>  
&emsp;&emsp;无向图G=(V,{E})中从顶点v到顶点v'的路径(Path)是一个顶点序列(v=v~i,0~,v~i,1~,...,v~i,m~=v')，其中(v~i,j-1~,v~i,j~)$\in$E，1<=j<=m。例如图7.7所示就列举另外顶点B到顶点D四种不同的路径:  

<div align="center"><img src="data_structure_image/7/7.7.png"></div>  

&emsp;&emsp;如果G是有向图，则路径也是有向的，顶点序列应满足<V~i,j-1~,V~i,j~>$\in$E，1<=j<m。例如图7.8，顶点B到D有两种路径。  

<div align="center"><img src="data_structure_image/7/7.8.png"></div>  

&emsp;&emsp;如果G是有向图，则路径也是有向的，顶点序列应满足<V~i,j-1~,V~i,j~>$\in$E,1<=j<m，顶点B到D有两种路径。而顶点A到B，就不存在路径。如图7.9所示  

<div align="center"><img src="data_structure_image/7/7.9.png"></div>  

&emsp;&emsp;树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。  
&emsp;&emsp;<b>路径的长度是路径上的边或弧的数目。</b>图7.8中左侧两条路的长度为2，右侧两条路径长度为3。图7.9中左侧路径长为2，右侧路径长度为3。  
&emsp;&emsp;<b>第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</b>图7.10中两个图的粗线都构成环，左侧的环因第一个顶点和最后一个顶点都是B，且C、D、A没有重复出现，因此是一个简单环。而右侧的环，由于顶点C的重复，它就不是简单环了。  

<div align="center"><img src="data_structure_image/7/7.10.png"></div>

### 7.1.3 连通图相关术语  

&emsp;&emsp;<b>在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点v~i~，v~j~$\in$E,v~i~和v~j~都是连通的，则称G是连通图(Connected Graph)。</b>图7.11图的图1，它的顶点A到顶点B、C、D、都是连通的，但显然A与顶点E或F就无路径，因此不能算是连通图。而图7.11中的图2，定点A、B、C、D相互都是连通的，所以它本身是连通图。  

<div align="center"><img src="data_structure_image/7/7.11.png"></div>

&emsp;&emsp;<b>无向图中的极大连通子图称为连通分量。</b>注意联通分量的概念，它强调：  
- 要是子图；
- 子图要是连通的；
- 连通子图含有极大顶点数；
- 具有极大顶点数的联通子图包含依附于这些顶点的所有边。  

&emsp;&emsp;<b>在有向图G中，如果对于每一对v~i~，v~j~$\in$V、v~i~不等于v~j~，从v~i~到v~j~和从v~j~到v~i~都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。</b>例如图7.12，图1并不是强连通图，因为顶点A到顶点D存在路径，而D到A就只存在。图2就是强连通图，而且显然图2是图1的极大强连通子图，既是它的强连通分量。  

<div align="center"><img src="data_structure_image/7/7.12.png"></div>

&emsp;&emsp;现在查看连通图的生成树定义。  
&emsp;&emsp;所谓的一个<b>连通图的生成树是一个极小的连通子图。它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</b>。比如图7.13的图1是一普通图，但显然它不是生成x树，当去掉两条构成环的边后，比如图2和图3，就满足n个顶点n-1条边且联通的定义了。它们都是一棵生成树。从这里也知道，如果一个图有n个顶点n-1条边和小于n-1条边，则是非连通图，如果它多于n-1条边，必定构成一个环，因为这条边使得它依附的那个顶点之间有了第二条路径。比如图2和图3,随便加哪两个顶点的边都将构成环。不过有n-1条边并不一定是生成树，比如图4。 

<div align="center"><img src="data_structure_image/7/7.13.png"></div>

&emsp;&emsp;<b>如果一个有向图恰好有一个顶点的入度为0,其余顶点的入度均为1,则是一棵有向树。</b>对有向树的理解也比较容易，所谓入度为0其实 就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个。一个<b>有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</b>如7.14图的图1是一棵有向图。去掉一些弧后，它可以分解为两棵有向树，如图2、3,这两棵就是图1有向图的生成森林。  

<div align="center"><img src="data_structure_image/7/7.14.png"></div>

### 7.1.4 图的定义与术语总结

&emsp;&emsp;<font color=red>图</font>按照有无方向分为<font color=blue>无向图和有向图</font>。无向图由<font color=red>顶点和边构成</font>，有向图由<font color=red>顶点和弧</font>构成。弧有<font color=blue>弧尾和弧头之分</font>。  
&emsp;&emsp;图按照边或弧的多少分<font color=blue>稀疏图和稠密图</font>。如果任意两个顶点之间都存在边叫<font color=blue>完全图</font>，有向的叫<font color=blue>有向完全图</font>。若无重复的边或顶点到自身的边则叫<font color=blue>简单图</font>。  
&emsp;&emsp;图中顶点之间有<font color=blue>邻接点、依附</font>的概念。无向图顶点的边数叫做<font color=blue>度</font>，有向图顶点分为<font color=blue>入度和出度</font>。  
&emsp;&emsp;图上的边或弧上<font color=blue>带权则称为网</font>。  
&emsp;&emsp;图中顶点间存在<font color=blue>路径</font>，两顶点存在路径则说明是<b>连通</b>的，如果路径最终回到起始点则称为<font color=blue>环</font>，当环中不重复叫<font color=blue>简单路径</font>。若任意两顶点都是<b>连通</b>的，则图就是<font color=blue>连通图</font>，有向则称为<font color=blue>强连通图</font>。图中有子图，若子图极大连通则就是<font color=blue>连通分量</font>，有向的则称<font color=blue>强连通分量</font>。  
&emsp;&emsp;无向图中连通且n个顶点n-1条边叫做<font color=blue>生成树</font>，有向图中一顶点入度为0其余顶点入度为1的叫<font color=blue>有向树</font>。一个有向图由若干棵有向树构成生成<font color=blue>森林</font>。


## 7.2 图的抽象数据类型  

&emsp;&emsp;图作为一种数据结构，它的抽象类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的数据操作。

```
ADT 图(Graph)

Operation
    CreateGraph(*G,V,VR):按照顶点集V和边弧集VR的定义构造图G
    DestroyGraph(*G):图G存在则销毁  
    LocateVex(G,u):若图G中存在顶点u，则返回图中的位置
    GetVex(G,v):返回图G中顶点v的值
    PutVex(G,v,value):将图G中顶点v赋值value
    FirstAdjVex(G,*v)：返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空
    NextAdjVex(G,v*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”
    InsertVex(*G,v):在图G中增添新顶点v
    DeleteArc(*G,v):删除图G中顶点v及其相关的弧
    InsertArc(*G,v,w):在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>
    DeleteArc(*G,v,w):在图G中删除弧<v,w>,若G是无向图，则还删除对称弧<w,v>
    DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用
    HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用
endADT
```

## 7.3 图的存储结构  

&emsp;&emsp;图的存储结构相较线性表与树来说就更加复杂了。首先，我们口头上说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系。比如图7.15中的四张图，仔细观察发现，它们其实是同一个图，只不过顶点的位置不同，就造成了表象上不太一样的感觉。  

<div align="center"><img src="data_structure_image/7/7.15.png"></div>

&emsp;&emsp;也正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是有问题的。如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的的顶点结构，又带来操作的不便。因此，对于图来说，如何对它实现物理存储是个难题，不过我们的前辈们已经解决了，现在我们来看看前辈们提供的五种不同的存储结构。  

### 7.3.1 邻接矩阵  

&emsp;&emsp;考虑到图是由顶点和边或弧两部分组成。合成一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。于是我们的邻接矩阵的方案就诞生了。  

&emsp;&emsp;<b>图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</b>  
&emsp;&emsp;设图G有n个顶点，则邻接矩阵是一个nxn的方阵，定义为:arc[i][j] = 1,若(v~i~,v~j~)$\in$E或<v~i~,v~j~>$\in$E。arc[i][j] = 0，则相反。我们来看一个实例，图7.16的左图。  

<div align="center"><img src="data_structure_image/7/7.16.png"></div>

&emsp;&emsp;我们可以设置两个数组，顶点数组为vertex[4]={v~0~,v~1~,v~2~,v~3~}，边数组arr[4][4]为图7.16右图这样的一个矩阵。简单解释一下，对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点到自身的边，比如v~0~到v~0~。arc[0][1]=1是因为v~0~到v~1~的边存在，而arc[1][3]=0是因为v~1~到v~3~的边不存在。并且由于是无向图，v~1～到v~3~的边不存在，意味着v~3~到v~1~的边也不存在。所以无向图的边数组是一个对称矩阵。  
&emsp;&emsp;嗯？对称矩阵是什么？忘记了不要紧，复习一下。所谓对称矩阵就是n阶矩阵的元满足a~ij~=a~ji~，（0<=i,j<=n）。即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。  
&emsp;&emsp;有了这个矩阵，我们就可以很容易地知道图中的信息。  
1. 我们要判定任意两顶点是否有边无边就非常容易了。  
2. 我们要知道某个顶点的度，其实就是这个顶点v~i在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v~i~的度就是1+0+1+0=2。
3. 求顶点v~i~的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1即是1邻接点。  

&emsp;&emsp;我们再来看一个有向图样例，如图7.17所示左图：  

<div align="center"><img src="data_structure_image/7/7.17.png"></div>

&emsp;&emsp;顶点数组为vertex[4]={v~0~,v~1~,v~2~,v~3~}，弧数组arc[4][4]为图7.17右图这样的一个矩阵。主对角线上数值依然为0.但因为是有向图，所以此矩阵并不对称，比如由v~1~到v~0~有弧，得到arc[1][0]=1，而v~0~到v~1~没有弧，因此arc[0][1]=0。  
&emsp;&emsp;有向图讲究入度与出度，顶点v~1~的入度为1,正好是第v~1~列各数之和。顶点v~1~的出度为2,即第v~1~行各数的和。  
&emsp;&emsp;与无向图同样的方法，判断顶点v~i~到v~j~是否存在弧，只需要查找矩阵中arc[i][j]是否为1即可。  
 &emsp;&emsp;在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。  
 &emsp;&emsp;设图G是网图，有n个顶点，则邻接矩阵是一个nxn的方阵，定义为: arc[i][j] = W~ij~,若(v~i~,v~j~)$\in$E或<v~i~,v~j~>$\in$E； 若i = j,arc[i][j] = 0;反之 arc[i][j] = $\infin$。  
 &emsp;&emsp;这里W~ij~表示(v~i~,v~j~)或者<v~i~,v~j~>上的权值。$\infin$表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于权值w~ij~大多数情况写是正值，但个别时候可能就是0,甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。如图7.18左图就是一个有向网图，右图就是它的邻接矩阵。  

<div align="center"><img src="data_structure_image/7/7.18.png"></div>  

&emsp;&emsp;那么邻接矩阵是如何实现图的创建的呢？我们先来看看图的邻接矩阵存储的结构，代码如下。  
```
typedef char VertexType;            /*顶点类型应由用户定义*/
typedef int EdgeType;               /*边上的权值类型应由用户定义*/
#define MAXVEX 100;                 /*最大顶点数，应由用户定义*/
#define INFINITY 65535              /*用65535代表无穷大*/

typedef struct
{
    VertextType vexs[MAXVEX];       /*顶点表*/
    EdgeType arc[MAXVEX][MAXVEX];   /*邻接矩阵，可看作边表*/
    int numVertexes, numEdges;      /*图中当前的顶点数和边数*/
}MGraph;
```
&emsp;&emsp;有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过程。我们来看看无向网图的创建代码。  
```
/*建立无向网图的邻接矩阵表示*/
void CreateMGraph(MGraph *G)
{
    int i,j,k,w;
    printf("输入顶点数和边数:\n");
    scanf("%d,%d",&G->numVertexes,);    /*输入顶点数和边数*/
    for(i = 0, i < G->numVertexes; i++) /*读入顶点信息，建立顶点表*/
    {
        scanf(&G->vexs[i]);
    }
    for(i  = 0; i< G->numVertexes; j++)
    {
        for(j = 0; j< G->numVertexes; j++)
        {
            G->arc[i][j] = INFINITY;    /*邻接矩阵初始化*/
        }
    }

    for(k = 0; k < G->numEdges; k++)    /*读入numEdges条边，建立邻接矩阵*/
    {
        printf("输入边(Vi,Vj)上的下标i,下标j和权w:\n");
        scanf("%d,%d,%d",&i,&j,&w);     /*输入边(vi,vj)上的权w*/
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];    /*因为是无向图，矩阵对称*/
    }
}
```

&emsp;&emsp;从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n^2^+e)，其中对邻接矩阵Garc的初始化耗费了O(n^2^)的时间。  

